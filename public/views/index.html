<!doctype html>
<html lang="en">
<!--<body style="background-color:green;">-->
<body style="min-width:500px;min-height:500px;">
<head>
<meta charset="UTF-8">
<title>Canvas Basic Game Template</title>
<script src="/socket.io/socket.io.js"></script>
<script type="text/javascript" src="http://code.jquery.com/jquery-3.1.1.min.js">
</script>  
<script type="text/javascript">


  var socket = io()
  testing()
  function testing() {
    let testnum = 0
    socket.emit('posttest');
    socket.emit("testnum", {number: testnum})
    //alert("yummy")
  }
      

window.addEventListener('load', eventWindowLoaded, false);

function eventWindowLoaded() {
   canvasApp();
}
  //"canvasApp" is the main function
function canvasApp(){


   var theCanvas = document.getElementById("canvas");
theCanvas.addEventListener("mousemove",onMouseMove,false);
theCanvas.addEventListener("click",onMouseClick,false);

 

   if (!theCanvas || !theCanvas.getContext) {
      return;
   }

  //var bob = theCanvas.getContext("2d");
   var context = theCanvas.getContext("2d");

   if (!context) {
      return;
   }
/*
   var bobImg = new Image();
    bobImg.addEventListener("load", function() {
        bob.drawImage(bobImg, 35, 35, 400, 400);
    }, false);

    bobImg.src = "wario.png";
*/

   //canvasApp level variables

   var rotation = 0.0;

   var keyPressList = [];
   var mouseX = 0;
   var mouseY = 0;
   var click = false;
   var pieceMove = false
   let UniversalPointer = null
   let Person1turn
   //for some reason, the Person1Turn is only actually updated once someone else joins mid-match, maybe is is some bug also related to pieces not being updated on first turns?
   //alert("david")
   /*
   socket.on('getturn', (elem1) => {
    Person1turn = elem1
    alert(Person1turn + " Hey there!")
  });
  */
  
   socket.emit('getturn');

   socket.on('getturn', (elem1) => {
      Person1turn = elem1
      if(Person1turn)//have no idea why, but this alert allows the game to function properly
      {
        alert("Green goes!")
      }
      else if(!Person1turn)
      {
        alert("White goes!")
      }
   });
   
  
  /*
   socket.emit("getturn",(response) => {
    Person1turn = response.status
    alert(response.status); // ok
  });
  */


   let firstTime

   let LocalBoardArray = []
   LocalBoardArray.length = 8

   for(let i = 0; i < LocalBoardArray.length; i++)
   {
    LocalBoardArray[i] = new Array(8)
   }

   let LocalPieceArray = []
   LocalPieceArray.length = 24

   //let ate = 0
   let Indentification = 0
   //var displayer;

      //need to test with other computers in a bit
      socket.on('getid', (elem1) => {
        //alert(typeof elem1)
        let daNum = (elem1%2)
        Indentification = daNum
          //alert(elem1);
          //alert(daNum)
          alert(Indentification + " is the id")
        });

   //alert(Indentification + " + 1 is the client id")


   gameLoop();

///////////////////////////////////////////////////////
   function gameLoop()
   {
        var FRAME_RATE = 40;
        var intervalTime = 1000/FRAME_RATE;
        input();
        paint();
        animate();
        window.setTimeout(gameLoop, intervalTime);
   }
/*
   document.onkeydown = function(e){
      e = e?e:window.event;
      keyPressList[e.keyCode] = true;
   }

   document.onkeyup = function(e){
      e = e?e:window.event;
      keyPressList[e.keyCode] = false; //if key is no long being pressed, then it is set to false (won't do anything till pressed again)
   };
   */

///////////////////////////////////////////////////////
/* //*note* this does work
  function useSocket (info) {
    if(info == "piecemove")
    {
      //alert("hey there")
      socket.on('piecemove', (elem1) => {
        alert("complete moved")
        Data(elem1)
      });
    }
    else if(info == "piecedelete")
    {
      socket.on('piecedelete', (elem1) => {
        alert("complete deleted")
        Data(elem1)
      });
    }
  }
  */

  socket.on('piecemove', (elem1) => {
    Data(elem1)
  });


   function onMouseMove(e)
   {
        //mouseX = e.clientX - theCanvas.offsetLeft;
        //mouseY = e.clientY - theCanvas.offsetTop;
        mouseX = e.clientX;
        mouseY = e.clientY;
   }
   function onMouseClick(e)
   {
    //socket.emit('getturn');
    //socket.emit('mouseclick',{number : david}); //this works

        //click = !click; //every other click, click is true
        click = true

        let xscale = innerWidth*.009
        let yscale = innerHeight*.009
        let scale = 0
        if(xscale >= yscale)
        {
          scale = yscale
        }
        else if(yscale > xscale)
        {
          scale = xscale
        }

        let pt = UniversalPointer

        for(let i = 0; i < LocalPieceArray.length; i++)
        {
          if(click && !pieceMove)
          {
            if(mouseX < LocalPieceArray[i].XVALUE + ((scale*10)/2) && mouseX > LocalPieceArray[i].XVALUE - ((scale*10)/2) && mouseY < LocalPieceArray[i].YVALUE + ((scale*10)/2) && mouseY > LocalPieceArray[i].YVALUE - ((scale*10)/2))
            {
              UniversalPointer = LocalPieceArray[i]
              pieceMove = true  
              return
         
              //alert("piece clicked")
              //LocalPieceArray[i].Color = '#808080'
              //displayer = "grey";            
            }
          }
          else if(click && pieceMove)
          {
            let xval = innerWidth * (1/3)
            let yval = innerHeight * (1/9)

            let xscale = innerWidth*.009
            let yscale = innerHeight*.009
            let scale = 0
            if(xscale >= yscale)
            {
              scale = yscale
            }
            else if(yscale > xscale)
            {
              scale = xscale
            }

            for(let b = -1; b < 2; b+=2)
            {
              for(let w = -1; w < 2; w+=2) //currently so it is diagnal (up or diagnal down)
              {
                let upordown = -1
                if(pt.Type == "king")
                {
                  upordown = (w*b)
                }
                else if(pt.Color == '#00FF00')
                {
                  upordown = -1
                }
                else if(pt.Color == '#FFFFFF')
                {
                  upordown = 1
                }

                let placeX3 = (xval+((pt.Column + w)*(scale*10))) + ((scale*10)/2)
                let placeY3 = (yval+((pt.Row + upordown)*(scale*10))) + ((scale*10)/2)

                //let placeX4 = (xval+((pt.Column - w)*(scale*10))) + ((scale*10)/2)
                //let placeY4 = (yval+((pt.Row - upordown)*(scale*10))) + ((scale*10)/2)

                if(mouseX < placeX3 + (((scale*10)/2)) && mouseX > placeX3 - (((scale*10)/2)) && mouseY < placeY3 + (((scale*10)/2)) && mouseY > placeY3 - (((scale*10)/2)))
                {
                  //alert(!Person1turn + " is the opposite")
                  //alert(typeof Person1turn)
                  //alert("w = " + w + " and upordown = " + upordown)
                  //else
                  {
                    if(LocalBoardArray[pt.Column + w][pt.Row + upordown].Status == null)
                    {
                      if(Indentification == 0 && Person1turn && pt.Color == '#00FF00' && pt.Type == "king")
                      {
                        //alert("hi")
                        //Person1turn = false
                        //alert(Person1turn + " player's 2 turn is next")
                        pieceMove = false
                        UniversalPointer = null
                        let hurr = JSON.stringify(pt)
                        socket.emit('piecemove',{IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : w, Rownew : upordown, index: pt.id, type: "king"});

                        //$.post("/update", {IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : w, Rownew : upordown, index: pt.id, type: "king"},Data);
                        //paint()
                        return
                      }
                      else if(Indentification == 1 && !Person1turn && pt.Color == '#FFFFFF' && pt.Type == "king")
                      {
                        //alert("hi2")
                        //Person1turn = false
                        //alert(Person1turn + " player's 1 turn is next")
                        pieceMove = false
                        UniversalPointer = null
                        let hurr = JSON.stringify(pt)

                        socket.emit('piecemove',{IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : w, Rownew : upordown, index: pt.id, type: "king"});

                        //$.post("/update", {IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : w, Rownew : upordown, index: pt.id, type: "king"},Data);
                        //paint()
                        return
                      }
                      else if(Indentification == 0 && Person1turn && pt.Color == '#00FF00')
                      {
                        //Person1turn = false
                        //alert(Person1turn + " player's 2 turn is next")
                        pieceMove = false
                        UniversalPointer = null
                        let hurr = JSON.stringify(pt)
                        let barcle = "normal"
                        if(pt.Row + upordown == 0)
                        {
                          barcle = "king"
                        }

                        //socket.on('connect', () => {
                          //the first moves don't seem to connect/update with other clients (maybe because of how the "every other turn" thing is set up) (or maybe try doing a check-up when the client first loads in) (it currently works if each person plays the game by placing green on their side, then white, etc.)(maybe do it based on user id) (or use io.emit instead of socket)
                          socket.emit('piecemove',{IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : w, Rownew : upordown, index: pt.id, type: barcle});

                         //});

                        //$.post("/update", {IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : w, Rownew : upordown, index: pt.id, type: barcle},Data);
                        //paint()
                        return
                      }
                      else if(Indentification == 1 && !Person1turn && pt.Color == '#FFFFFF')
                      {
                        //Person1turn = true
                        //alert(Person1turn + " player's 1 turn is next")
                        pieceMove = false
                        UniversalPointer = null
                        let hurr = JSON.stringify(pt)
                        let barcle = "normal"
                        if(pt.Row + upordown == 7)
                        {
                          barcle = "king"
                        }

                        socket.emit('piecemove',{IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : w, Rownew : upordown, index: pt.id, type: barcle});

                        //$.post("/update", {IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : w, Rownew : upordown, index: pt.id, type: barcle},Data);
                        //paint()
                        return
                      }
                    }
                    else if(LocalBoardArray[pt.Column + w][pt.Row + upordown].Status != null)
                    {
                      //alert("is here")
                      if(Indentification == 0 && Person1turn && pt.Color == '#00FF00')
                      {
                        let num1 = parseInt(pt.Column + w)
                        let num2 = parseInt(pt.Row + upordown)
                        //alert("eyo wus up")
                        //alert((num1 + w) + " is num1 and num2 is " + (num2 + upordown))
                        let num3 = num1 + w
                        let num4 = num2 + upordown
                        //alert(LocalBoardArray[num3][num4].Status)
                        //alert(LocalBoardArray[num1][num2].Status.Color)
                        if(LocalBoardArray[num1][num2].Status.Color == '#FFFFFF')
                        {
                          //alert("HELOOOO")
                          //alert(num3 + " num3 is and num4 is " + num4)
                          let gary = LocalBoardArray[num1][num2]
                          let hurr = JSON.stringify(pt)
                          if(num2 == 0 || num2 == 7 || LocalBoardArray[num3][num4].Status == null)
                          {
                            //alert("yooooo")

                            //Person1turn = false
                            alert(Person1turn + " player's 2 turn is next")
                            pieceMove = false
                            UniversalPointer = null

                            socket.emit('piecedelete',{IsHere: gary, CoL: num1, ROW: num2, index: gary.Status.id});
                                //////////does not call socket.on
                            socket.on('piecedelete', (elem1) => {
                              Data(elem1)
                            });

                             //$.post("/outofbounds", {IsHere: gary, CoL: num1, ROW: num2, index: gary.Status.id},Data);

                            if(num4 == 0 || num2 == 0 || num2 == 7 || pt.Type == "king")
                            {
                              //alert("num3 = " + num3 + " and num4 = " + num4)
                              /////can move up and down right, but not down left
                              let number = 2
                              if(num2 == 0 || num2 == 7)
                              {
                                number = 1
                              }
                                socket.emit('piecemove',{IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : w*number, Rownew : upordown*number, index: pt.id, type: "king"});

                               //$.post("/update", {IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : (w*number), Rownew : (upordown*number), index: pt.id, type: "king"},Data);
                            }
                            else
                            {
                              socket.emit('piecemove',{IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : w*2, Rownew : upordown*2, index: pt.id, type: "normal"});

                              //$.post("/update", {IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : (w*2), Rownew : (upordown*2), index: pt.id, type: "normal"},Data);
                            }

                            //paint()
                            return false
                          }
                        }
                      }
                      else if(Indentification == 1 && !Person1turn && pt.Color == '#FFFFFF')
                      {
                        let num1 = parseInt(pt.Column + w)
                        let num2 = parseInt(pt.Row + upordown)

                        let num3 = num1 + w
                        let num4 = num2 + upordown

                        if(LocalBoardArray[num1][num2].Status.Color == '#00FF00')
                        {
                          //alert("HELOOOO")
                          let gary = LocalBoardArray[num1][num2]
                          let hurr = JSON.stringify(pt)
                          if(num2 == 7 || num2 == 0 || LocalBoardArray[num3][num4].Status == null)
                          {
                            //alert("yooooo2")

                            //Person1turn = true
                            //alert(Person1turn + " player's 1 turn is next")
                            pieceMove = false
                            UniversalPointer = null

                            socket.emit('piecedelete',{IsHere: gary, CoL: num1, ROW: num2, index: gary.Status.id});


                            socket.on('piecedelete', (elem1) => {
                              Data(elem1)
                            });



                             //$.post("/outofbounds", {IsHere: gary, CoL: num1, ROW: num2, index: gary.Status.id},Data);

                             //this shoudl update the piece being moved
                            if(num4 == 7 || num2 == 0 || num2 == 7 || pt.Type == "king")
                            {
                              if(num2 == 0 || num2 == 7)
                              {
                                number = 1
                              }
                              socket.emit('piecemove',{IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : w*number, Rownew : upordown*number, index: pt.id, type: "king"});

                               //$.post("/update", {IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : (w*number), Rownew : (upordown*number), index: pt.id, type: "king"},Data);
                            }
                            else
                            {
                              socket.emit('piecemove',{IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : w*2, Rownew : upordown*2, index: pt.id, type: "normal"});

                              //$.post("/update", {IsHere: hurr, COL: pt.Column, ROW: pt.Row, Colnew : (w*2), Rownew : (upordown*2), index: pt.id, type: "normal"},Data);
                            }

                            //paint()
                            return false
                          }
                        }
                      }
                    }
                  }

                }
              }
            }
          }
        }
        UniversalPointer = null
        pieceMove = false


   }
   function input()
   {
       if (keyPressList[38]==true){
       //Up arrow
       }

       if (keyPressList[37]==true) {
       //Left arrow
       }

       if (keyPressList[39]==true) {
       //Right arrow
       }
   }

   function Data(info) {
    /*
      socket.on('getturn', (elem1) => {
        Person1turn = elem1
        alert(Person1turn)
      });
      */

     if(info != null && info.TURN != null)
     {
      //now updates for both, but currently cannot fix update on first move
      Person1turn = info.TURN
      socket.emit('getturn');
      //alert(typeof info.TURN)
      //alert(info.TURN)
     } 


      let xval = innerWidth * (1/3)
      let yval = innerHeight * (1/9)

      let xscale = innerWidth*.009
      let yscale = innerHeight*.009
      let scale = 0
      if(xscale >= yscale)
      {
        scale = yscale
      }
      else if(yscale > xscale)
      {
        scale = xscale
      }

      for(let i = 0; i < LocalBoardArray.length; i++)
      {

        for(let j = 0; j < LocalBoardArray[i].length; j++)
        {        
          let placeX = xval+(i*(scale*10))
          let placeY = yval+(j*(scale*10))

          if(info != null)
          {
            LocalBoardArray[i][j] = {XVALUE:placeX,YVALUE:placeY,ROTATION:rotation,SCALE:scale,Column:info.BOARD[i][j].COL,Row:info.BOARD[i][j].ROW,Color:info.BOARD[i][j].COLOR,Status:info.BOARD[i][j].STAT}
            //alert("eyo2")
            //alert(JSON.stringify(LocalBoardArray[i][j]))
         }
         else if(info == null)
         {
           let pt = LocalBoardArray[i][j]
           LocalBoardArray[i][j] = {XVALUE:placeX,YVALUE:placeY,ROTATION:rotation,SCALE:scale,Column:pt.Column,Row:pt.Row,Color:pt.Color,Status:pt.Status}
         }
        }
      }
    for(let i = 0; i < LocalPieceArray.length; i++)
    {

      if(info != null)
      {
        //let unknownVariable = info.UMidk
        //alert(unknownVariable)

        let placeX3
        let placeY3

        if(info.PIECE[i].COL == null || info.PIECE[i].COL == undefined)
        {
          placeX3 = 100
        }
        else
        {
           placeX3 = (xval+((info.PIECE[i].COL)*(scale*10))) + ((scale*10)/2)
        }
        if(info.PIECE[i].ROW == null || info.PIECE[i].ROW == undefined)
        {
          placeY3 = 100
        }
        else
        {
           placeY3 = (yval+((info.PIECE[i].ROW)*(scale*10))) + ((scale*10)/2)
        }

        let image = document.createElement("img")
        image.src = info.PIECE[i].IMAGE

        //alert(info.PIECE[i].TYPE)

        LocalPieceArray[i] = {XVALUE: placeX3, YVALUE: placeY3, SCALE: (scale*4), Column: info.PIECE[i].COL, Row: info.PIECE[i].ROW, sANGLE: (0*Math.PI), eANGLE: (2*Math.PI),id: info.PIECE[i].INDEX, Color: info.PIECE[i].COLOR, IMG: image, Type: info.PIECE[i].TYPE}
        //alert(JSON.stringify(LocalPieceArray[i]))
        //alert(LocalPieceArray[info.PIECE[i].INDEX].id)
        //alert(info.UMidk)
        if(info.UMidk == undefined || info.UMidk != "questionmark")
        {
          //alert(unknownVariable)
          //alert("eyo1")

          //by default all areas of the board have an empty status, so this code here (once the pieces are all displayed) updates the board, so the indexes of the board (with pieces on them) will not have an empty status (this is *only* done here so we don't have to manually set certain board indexes to not be empty)
          let hurr = JSON.stringify(LocalPieceArray[i])

          socket.emit('request',{IsHere: hurr, COL: info.PIECE[i].COL, ROW: info.PIECE[i].ROW});
        
          socket.on('request', (elem1) => {
            Data(elem1)
          });

          //$.post("/request", {IsHere: hurr, COL: info.PIECE[i].COL, ROW: info.PIECE[i].ROW},Data);
          //return
        }
      }
      else if(info == null)
      {
        let pt = LocalPieceArray[i]

        let placeX3 = (xval+((pt.Column)*(scale*10))) + ((scale*10)/2)
        let placeY3 = (yval+((pt.Row)*(scale*10))) + ((scale*10)/2)

        LocalPieceArray[i] = {XVALUE: placeX3, YVALUE: placeY3, SCALE: (scale*4), Column: pt.Column, Row: pt.Row, sANGLE: (0*Math.PI), eANGLE: (2*Math.PI),id: pt.id, Color: pt.Color, IMG: pt.IMG, Type: pt.Type}
      }
     
    }
    //alert(JSON.stringify(LocalPieceArray[0]))
   }

   function paint()
   {

   if(firstTime == undefined) {
        // first time code goes here
        firstTime = "TurkeyTime"; //do the initialisation
        socket.emit('recieve');

        socket.on('recieve', (elem1) => {
          //alert(JSON.stringify(elem1))
          Data(elem1)
       });
        //$.get("/recieve", Data);
        return false
    }

   // draw background
   context.fillStyle = '#808080';
   //context.fillRect(xval, yval, 480, 480);
   context.fillRect(0, 0, innerWidth, innerHeight);

/*
      context.fillStyle =  displayer;
   context.fillRect(550, 20, 900, 900);
   */


   //Text output
   context.fillStyle = '#ffffff';
   context.font = '10px sans-serif';
   context.textBaseline = 'top';
   if (click)
       context.fillText  ("click", 0, 180);
   else
       context.fillText  ("" + mouseX + " " + mouseY, 0, 180);

  for(let i = 0; i < 8; i++)
  {
    for(let j = 0; j < 8; j++)
    {
      if(LocalBoardArray[i][j] == undefined)
      {
        //alert("LocalBoardArray index" + i + " === " + j +  " is undefined!")
        return false
      }
     
      let my = LocalBoardArray[i][j]

      if(i % 2 == 0)
      {
        if(j % 2 == 0)
        {
          drawRect(my.XVALUE,my.YVALUE,my.ROTATION,my.SCALE,my.SCALE,my.Color);
        }
        else if(j % 2 == 1)
        {        
          drawRect(my.XVALUE,my.YVALUE,my.ROTATION,my.SCALE,my.SCALE,my.Color);
       }      
      }
      else if(i % 2 == 1)
      {
        if(j % 2 == 1)
        {
          drawRect(my.XVALUE,my.YVALUE,my.ROTATION,my.SCALE,my.SCALE,my.Color);
        }
        else if(j % 2 == 0)
        {
          drawRect(my.XVALUE,my.YVALUE,my.ROTATION,my.SCALE,my.SCALE,my.Color);
        }
      }
    }  
  }

  for(let ate = 0; ate < LocalPieceArray.length; ate++)
  {
      if(LocalPieceArray[ate] == undefined)
      {
        //alert("LocalPieceArray index " + ate + " is undefined!")
        return false
      }

      let baby = LocalPieceArray[ate]
      if(baby.Column != null && baby.Row != null)
      {
        drawArc(baby.XVALUE,baby.YVALUE,baby.SCALE,baby.sANGLE,baby.eANGLE,baby.Color)

        if(baby.Type == "king")
        {
          drawArc(baby.XVALUE,baby.YVALUE,baby.SCALE/2,baby.sANGLE,baby.eANGLE,"#FFFF00")
        }
      }
         
  }
   
    window.onresize = function() {      
        // Setting the current height & width
        // to the elements    
        if(firstTime != undefined)
        {    
          $("#canvas").attr("width","" + innerWidth)
          $("#canvas").attr("height","" + innerHeight)
          //image1.width = 500
          //image1.height = 500
          //CAN/MAYBE WILL BE USED FOR LATER
          paint();
          Data(null)
        }
        return false
    };

   return false;

   }

   function drawRect(xpos,ypos,rot,xscale,yscale,color)
   {
        context.save(); //save current state in stack
        context.setTransform(1,0,0,1,0,0);

        context.translate(xpos,ypos);
        context.rotate(rot);
        context.scale(xscale,yscale);
        context.fillStyle = color;
        context.beginPath();
        context.fillRect(0,0,10,10);

        context.restore(); //pop old state on to screen
   }

   function drawArc(xpos,ypos,radius,sAngle,eAngle,color)
   {
      this.xpos = xpos
      this.ypos = ypos
      this.radius = radius
      this.sAngle = sAngle
      this.eAngle = eAngle
      this.color = color
        context.save(); //save current state in stack
        context.setTransform(1,0,0,1,0,0);

        context.translate(xpos,ypos);
        context.fillStyle = color;
        context.beginPath();
        context.arc(0,0,radius,sAngle,eAngle);
        context.fill()

        context.restore(); //pop old state on to screen
   }

   function animate()
   {
       
   
   }


}



////////////////////////////////////////////////////////

</script>
</head>


<body>

<canvas id="canvas" width="1000" height="1000" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);">
 Your browser does not support HTML5 Canvas.
</canvas>

<!--<img id="image1" src="wario.png" alt="" width="500" height="500" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);"> --> <!-- CAN/MAYBE WILL BE USED FOR LATER -->



</body>
</html>

<script>
  $("#canvas").attr("width","" + innerWidth) //don't know why, but if put in quotes (and not a number) it won't actully get the screen dimentions, instead goes to some abscure default (like 100x100 [or somthing like that])
  $("#canvas").attr("height","" + innerHeight)

/*
  $("#image1").attr("width","" + ((innerHeight*.009)*10))
  $("#image1").attr("height","" + ((innerHeight*.009)*10))

  let bug = (innerWidth * (1/3)) + ((innerHeight*.009)*10) + "px"
  let bug2 = (innerHeight * (1/9)) + ((innerHeight*.009)*10) + "px"
  $("#image1").attr("style", "position:absolute;top:" + bug2 + ";left:" + bug + ";")
  //alert(bug)
  //alert(bug2)
  */
  //CAN/MAYBE WILL BE USED FOR LATER

</script>
<script src="js/home.js"></script>